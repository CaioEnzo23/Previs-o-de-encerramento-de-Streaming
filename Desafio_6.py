# -*- coding: utf-8 -*-
"""Desafio 6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1w1m_RR833-NLd7EkPw2e0G36KoonWniv

#**Setup**

Instalação de Bibliotecas
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install plotly
# %pip install cufflinks
# %pip install chart-studio

!pip install pandas-profiling
!pip install sidetable
!pip install scikit-learn

"""Importação das principais bilbiotecas ultilizadas"""

import pandas as pd
import seaborn as sns
import numpy as np
import matplotlib.pyplot as plt

import chart_studio.plotly as py
import cufflinks as cf

import plotly.graph_objects as go
import plotly.express as px

import missingno as msno
from ipywidgets import interact, widgets

from sklearn import datasets
from sklearn.preprocessing import scale, minmax_scale, power_transform
from sklearn.datasets import load_wine

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.pipeline import Pipeline
from sklearn.compose import ColumnTransformer

from sklearn.metrics import confusion_matrix
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
import matplotlib.pyplot as plt
from sklearn.metrics import classification_report
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import GridSearchCV
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import LabelEncoder

from sklearn.impute import SimpleImputer

from sklearn.metrics import accuracy_score, classification_report

"""#**Análise exploratória dos dados (Data Understanding)**

Importação de Dados
"""

df = pd.read_excel("/content/streaming_data.xlsx")

"""Realize uma descrição estatística dos dados"""

descricao = df.describe()
print(descricao)

""" Verifique os tipos de dados"""

df.info()

"""Verifique a quantidade de valores faltantes"""

df.isna()

df.isna().sum()

"""#**Tratamento dos Dados (Data Preparation)**

Substituir valores “NaN” por 0 Colunas → Time_on_platform,
Num_streaming_services, Churned, Avg_rating, Devices_connected
"""

colunas = ['Time_on_platform', 'Num_streaming_services', 'Churned', 'Avg_rating', 'Devices_connected']
df[colunas] = df[colunas].fillna(0)

print(df)

"""Dropar linhas nulas nas colunas Gender, Subscription_type e Age"""

colunas = ['Gender', 'Subscription_type', 'Age']
df_limpo = df.dropna(subset=colunas)

print(df_limpo)

"""Transformando valores churned 0 e 1 por No e Yes"""

df['Churned'] = df['Churned'].replace({0: 'No', 1: 'Yes'})

print(df)

"""Transformando valores floats em valores inteiros"""

df.dtypes

df.fillna({'Devices_connected': 0, 'Age': 0, 'Time_on_platform': 0,
           'Num_streaming_services': 0, 'Avg_rating': 0}, inplace=True)

df = df.astype({'Devices_connected': 'int', 'Age': 'int', 'Time_on_platform': 'int',
                'Num_streaming_services': 'int', 'Avg_rating': 'int'})

print(df)

"""#**Modelagem dos Dados - Regressão Logística**

Definir variáveis X e y para o modelo
"""

X = df[['Num_active_profiles','Time_on_platform', 'Num_streaming_services', 'Avg_rating', 'Devices_connected', 'Gender', 'Subscription_type', 'Age']]
y = df['Churned']

print("X:")
print(X)
print("\nY:")
print(y)

"""Separar em train e test"""

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

numeric_features = ['Time_on_platform', 'Num_streaming_services', 'Avg_rating', 'Devices_connected', 'Age']
categorical_features = ['Gender', 'Subscription_type']

numeric_transformer = StandardScaler()
categorical_transformer = OneHotEncoder(drop='first')

preprocessor = ColumnTransformer(
    transformers=[
        ('num', numeric_transformer, numeric_features),
        ('cat', categorical_transformer, categorical_features)
    ])

model = Pipeline(steps=[
    ('preprocessor', preprocessor),
    ('classifier', LogisticRegression())
])

""" Realizar o .fit do modelo"""

model.fit(X_train, y_train)

""" Realizar a modelagem"""

score = model.score(X_test, y_test)
print(f'Acurácia do modelo: {score:.2f}')

"""Plotar matrix confusão"""

y_pred = model.predict(X_test)

y_pred = model.predict(X_test)
cm = confusion_matrix(y_test, y_pred, labels=['No', 'Yes'])
print(cm)

disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=['No', 'Yes'])
disp.plot(cmap=plt.cm.Blues)
plt.show()

"""Printar métricas"""

report = classification_report(y_test, y_pred, target_names=['No', 'Yes'])
print(report)

"""#**Modelagem dos Dados - Tunning**

Definir variáveis X e y para o modelo
"""

X = df[['Time_on_platform', 'Num_streaming_services', 'Avg_rating', 'Devices_connected', 'Gender', 'Subscription_type', 'Age']]
y = df['Churned']

"""Separar em train e test"""

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

"""Realizar o .fit do modelo"""

numeric_features = ['Time_on_platform', 'Num_streaming_services', 'Avg_rating', 'Devices_connected', 'Age']
categorical_features = ['Gender', 'Subscription_type']

numeric_transformer = MinMaxScaler()
categorical_transformer = OneHotEncoder(drop='first')

preprocessor = ColumnTransformer(
    transformers=[
        ('num', numeric_transformer, numeric_features),
        ('cat', categorical_transformer, categorical_features)
    ])

model = Pipeline(steps=[
    ('preprocessor', preprocessor),
    ('classifier', LogisticRegression())
])

param_grid = {
    'classifier__penalty': ['l1', 'l2'],
    'classifier__C': [0.01, 0.1, 1, 10, 100],
    'classifier__solver': ['liblinear']
}

grid_search = GridSearchCV(estimator=model, param_grid=param_grid, cv=5, n_jobs=-1, verbose=1)

grid_search.fit(X_train, y_train)

"""Realizar a modelagem"""

best_model = grid_search.best_estimator_
best_params = grid_search.best_params_
print(f'Melhores parâmetros encontrados: {best_params}')

y_pred = best_model.predict(X_test)

"""Plotar matrix confusão"""

cm = confusion_matrix(y_test, y_pred, labels=['No', 'Yes'])

disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=['No', 'Yes'])
disp.plot(cmap=plt.cm.Blues)
plt.show()

"""Printar métricas"""

report = classification_report(y_test, y_pred, target_names=['No', 'Yes'])
print(report)

"""#**Modelagem dos Dados - Random Forest**

Realizar a montagem do grid search
"""

modelo = RandomForestClassifier(n_estimators=100, random_state=42)

parametros = {
    'n_estimators': [10, 50, 100, 200],
    'max_depth': [None, 5, 10, 15],
    'min_samples_split': [2, 5, 10],
    'min_samples_leaf': [1, 2, 4]
}

grid_search = GridSearchCV(modelo, parametros, cv=5, scoring='accuracy')

""" Realizar o .fit do modelo"""

X_train = np.array(X_train)
y_train = np.array(y_train)

assert not np.isnan(X_train).any(), "X_train contains NaN values"
assert not np.isnan(y_train).any(), "y_train contains NaN values"

print("Shape of X_train:", X_train.shape)
print("Shape of y_train:", y_train.shape)

X_train = X_train[:49019, :]

modelo = RandomForestClassifier(n_estimators=100, random_state=42)
modelo.fit(X_train, y_train)

""" Realizar o Tunning"""

print("Parâmetros do modelo:", modelo.get_params())

"""Realizar a modelagem"""

label_encoder = LabelEncoder()
X_test['Subscription_type'] = label_encoder.fit_transform(X_test['Subscription_type'])

imputer = SimpleImputer(strategy='most_frequent')

imputer.fit(X_test)

X_test_imputed = imputer.transform(X_test)

X_test_imputed = pd.DataFrame(X_test_imputed, columns=X_test.columns)

label_encoder = LabelEncoder()
X_test_imputed['Subscription_type'] = label_encoder.fit_transform(X_test_imputed['Subscription_type'])

y_pred = modelo.predict(X_test_imputed)

"""Plotar matrix confusão"""

y_pred = modelo.predict(X_test_imputed)

y_pred = y_pred[:15577]

y_test_cleaned = np.nan_to_num(y_test, nan=np.nanmedian(y_test))

cm = confusion_matrix(y_test_cleaned, y_pred)
disp = ConfusionMatrixDisplay(confusion_matrix=cm)
disp.plot()
plt.show()

"""Printar métricas"""

y_test = y_test.fillna(0)

print("Acurácia:", accuracy_score(y_test, y_pred))
print("Relatório de classificação:")
print(classification_report(y_test, y_pred))
